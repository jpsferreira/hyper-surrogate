import numpy as np
import pytest
import sympy as sym

from hyper_surrogate.kinematics import Kinematics as K
from hyper_surrogate.materials import NeoHooke

# seed random number generator
np.random.seed(0)


@pytest.fixture
def neohooke():
    return NeoHooke()


@pytest.fixture
def f0():
    # no deformation
    return np.array(np.eye(3))


@pytest.fixture
def f_uni():
    # uniaxial stretch 3 at x-axis. 3x3 matrix. 3,0,0; 0,1/sqrt(3),0; 0,0,1/sqrt(3)
    return np.array(np.diag([3, 1 / np.sqrt(3), 1 / np.sqrt(3)]))


@pytest.fixture
def f_arbitrary():
    return np.array([[3.0, 0.4, 0.1], [0.4, 1 / np.sqrt(3.0), 0.1], [0.9, -0.2, 0.6]])


@pytest.fixture
def f_arbitrary2():
    return np.array([[3.0, 0.4, 0.1], [0.4, 0.45, 0.1], [0.9, -0.2, 0.9]])


@pytest.fixture
def f(f0, f_uni, f_arbitrary, f_arbitrary2):
    return np.array([f0, f_uni, f_arbitrary, f_arbitrary2])


@pytest.fixture
def c_tensor(f):
    return K.right_cauchy_green(f)


@pytest.fixture
def cmat_iso0():
    # Initialize a 4D tensor of size 3x3x3x3
    tensor = np.zeros((3, 3, 3, 3))
    # Populate the tensor with the provided values
    tensor[0, 0, 0, 0] = 2.6666666666666661
    tensor[0, 0, 1, 1] = -1.3333333333333335
    tensor[0, 0, 2, 2] = -1.3333333333333335
    tensor[0, 1, 0, 1] = 2.0
    tensor[0, 1, 1, 0] = 2.0
    tensor[0, 2, 0, 2] = 2.0
    tensor[0, 2, 2, 0] = 2.0

    tensor[1, 0, 0, 1] = 2.0
    tensor[1, 0, 1, 0] = 2.0
    tensor[1, 1, 0, 0] = -1.3333333333333335
    tensor[1, 1, 1, 1] = 2.6666666666666661
    tensor[1, 1, 2, 2] = -1.3333333333333335
    tensor[1, 2, 1, 2] = 2.0
    tensor[1, 2, 2, 1] = 2.0

    tensor[2, 0, 0, 2] = 2.0
    tensor[2, 0, 2, 0] = 2.0
    tensor[2, 1, 1, 2] = 2.0
    tensor[2, 1, 2, 1] = 2.0
    tensor[2, 2, 0, 0] = -1.3333333333333335
    tensor[2, 2, 1, 1] = -1.3333333333333335
    tensor[2, 2, 2, 2] = 2.6666666666666661
    return tensor


@pytest.fixture
def cmat_iso_uni():
    """
    Fixture to create a 4D tensor for isotropic uniaxial stretch with the given values.
    """
    # Initialize a 4D tensor of size 3x3x3x3
    tensor = np.zeros((3, 3, 3, 3))

    # Populate the tensor with the corrected values
    tensor[0, 0, 0, 0] = -8.4133516232281630e-02
    tensor[0, 0, 1, 1] = -2.7160493827160477
    tensor[0, 0, 2, 2] = -2.7160493827160477
    tensor[0, 1, 0, 1] = tensor[0, 1, 1, 0] = 2.1481481481481466
    tensor[0, 2, 0, 2] = tensor[0, 2, 2, 0] = 2.1481481481481466
    tensor[1, 0, 0, 1] = tensor[1, 0, 1, 0] = 2.1481481481481466
    tensor[1, 1, 0, 0] = -2.7160493827160477
    tensor[1, 1, 1, 1] = 146.66666666666652
    tensor[1, 1, 2, 2] = 30.666666666666629
    tensor[1, 2, 2, 1] = tensor[1, 2, 1, 2] = 57.999999999999950
    tensor[2, 1, 2, 1] = tensor[2, 1, 1, 2] = 57.999999999999950
    tensor[2, 0, 0, 2] = tensor[2, 0, 2, 0] = 2.1481481481481466
    tensor[2, 2, 0, 0] = -2.7160493827160477
    tensor[2, 2, 1, 1] = 30.666666666666629
    tensor[2, 2, 2, 2] = 146.66666666666652
    return tensor


@pytest.fixture
def cmat_iso_arbitrary():
    # Initialize a 3x3x3x3 numpy array
    cmat = np.zeros((3, 3, 3, 3))

    # Full tensor data
    data = [
        (1, 1, 1, 1, 0.30193858284457098),
        (1, 1, 1, 2, -1.4370489436583369),
        (1, 1, 1, 3, -1.4435382478426262),
        (1, 1, 2, 1, -1.4370489436583369),
        (1, 1, 2, 2, 2.6354050581880939),
        (1, 1, 2, 3, 3.4990181431837080),
        (1, 1, 3, 1, -1.4435382478426262),
        (1, 1, 3, 2, 3.4990181431837080),
        (1, 1, 3, 3, 2.4260744143504436),
        (1, 2, 1, 1, -1.4370489436583369),
        (1, 2, 1, 2, 8.1421289164817097),
        (1, 2, 1, 3, 5.4210394221196125),
        (1, 2, 2, 1, 8.1421289164817097),
        (1, 2, 2, 2, -31.131706731899918),
        (1, 2, 2, 3, -20.720414983420653),
        (1, 2, 3, 1, 5.4210394221196125),
        (1, 2, 3, 2, -20.720414983420653),
        (1, 2, 3, 3, -19.732406613789706),
        (1, 3, 1, 1, -1.4435382478426262),
        (1, 3, 1, 2, 5.4210394221196125),
        (1, 3, 1, 3, 9.3658760679831481),
        (1, 3, 2, 1, 5.4210394221196125),
        (1, 3, 2, 2, -17.768839217120835),
        (1, 3, 2, 3, -23.629499827717773),
        (1, 3, 3, 1, 9.3658760679831481),
        (1, 3, 3, 2, -23.629499827717773),
        (1, 3, 3, 3, -39.103655664503229),
        (2, 1, 1, 1, -1.4370489436583369),
        (2, 1, 1, 2, 8.1421289164817097),
        (2, 1, 1, 3, 5.4210394221196125),
        (2, 1, 2, 1, 8.1421289164817097),
        (2, 1, 2, 2, -31.131706731899918),
        (2, 1, 2, 3, -20.720414983420653),
        (2, 1, 3, 1, 5.4210394221196125),
        (2, 1, 3, 2, -20.720414983420653),
        (2, 1, 3, 3, -19.732406613789706),
        (2, 2, 1, 1, 2.6354050581880935),
        (2, 2, 1, 2, -31.131706731899918),
        (2, 2, 1, 3, -17.768839217120835),
        (2, 2, 2, 1, -31.131706731899918),
        (2, 2, 2, 2, 185.33923639898384),
        (2, 2, 2, 3, 83.202888729367345),
        (2, 2, 3, 1, -17.768839217120835),
        (2, 2, 3, 2, 83.202888729367345),
        (2, 2, 3, 3, 78.788228348662926),
        (2, 3, 1, 1, 3.4990181431837080),
        (2, 3, 1, 2, -20.720414983420653),
        (2, 3, 1, 3, -23.629499827717773),
        (2, 3, 2, 1, -20.720414983420653),
        (2, 3, 2, 2, 83.202888729367345),
        (2, 3, 2, 3, 113.82682354865585),
        (2, 3, 3, 1, -23.629499827717773),
        (2, 3, 3, 2, 113.82682354865585),
        (2, 3, 3, 3, 104.03898308454664),
        (3, 1, 1, 1, -1.4435382478426262),
        (3, 1, 1, 2, 5.4210394221196125),
        (3, 1, 1, 3, 9.3658760679831481),
        (3, 1, 2, 1, 5.4210394221196125),
        (3, 1, 2, 2, -17.768839217120835),
        (3, 1, 2, 3, -23.629499827717773),
        (3, 1, 3, 1, 9.3658760679831481),
        (3, 1, 3, 2, -23.629499827717773),
        (3, 1, 3, 3, -39.103655664503229),
        (3, 2, 1, 1, 3.4990181431837080),
        (3, 2, 1, 2, -20.720414983420653),
        (3, 2, 1, 3, -23.629499827717773),
        (3, 2, 2, 1, -20.720414983420653),
        (3, 2, 2, 2, 83.202888729367345),
        (3, 2, 2, 3, 113.82682354865585),
        (3, 2, 3, 1, -23.629499827717773),
        (3, 2, 3, 2, 113.82682354865585),
        (3, 2, 3, 3, 104.03898308454664),
        (3, 3, 1, 1, 2.4260744143504436),
        (3, 3, 1, 2, -19.732406613789706),
        (3, 3, 1, 3, -39.103655664503229),
        (3, 3, 2, 1, -19.732406613789706),
        (3, 3, 2, 2, 78.788228348662926),
        (3, 3, 2, 3, 104.03898308454664),
        (3, 3, 3, 1, -39.103655664503229),
        (3, 3, 3, 2, 104.03898308454664),
        (3, 3, 3, 3, 289.84208473072965),
    ]

    for i, j, k, ll, value in data:
        cmat[i - 1, j - 1, k - 1, ll - 1] = value  # Adjust for 0-based indexing

    return cmat


@pytest.fixture
def cmat_iso_arbitrary2():
    """
    Fixture representing a 4D tensor with arbitrary isotropic data.
    The tensor shape corresponds to the 3x3x3x3 structure implied by the provided data.
    """
    data = [
        [1, 1, 1, 1, 0.60472436752719028],
        [1, 1, 1, 2, -3.1494209150312722],
        [1, 1, 1, 3, -1.6438110747420629],
        [1, 1, 2, 1, -3.1494209150312722],
        [1, 1, 2, 2, 10.293213981001511],
        [1, 1, 2, 3, 5.5785936405303111],
        [1, 1, 3, 1, -1.6438110747420629],
        [1, 1, 3, 2, 5.5785936405303111],
        [1, 1, 3, 3, 2.5501822048834013],
        [1, 2, 1, 1, -3.1494209150312722],
        [1, 2, 1, 2, 19.024376838885505],
        [1, 2, 1, 3, 8.0558318916305289],
        [1, 2, 2, 1, 19.024376838885505],
        [1, 2, 2, 2, -89.653784669207511],
        [1, 2, 2, 3, -36.745780464383401],
        [1, 2, 3, 1, 8.0558318916305289],
        [1, 2, 3, 2, -36.745780464383401],
        [1, 2, 3, 3, -19.192671848160998],
        [1, 3, 1, 1, -1.6438110747420629],
        [1, 3, 1, 2, 8.0558318916305289],
        [1, 3, 1, 3, 6.1599002820183753],
        [1, 3, 2, 1, 8.0558318916305289],
        [1, 3, 2, 2, -34.051435541355758],
        [1, 3, 2, 3, -22.501972722776095],
        [1, 3, 3, 1, 6.1599002820183753],
        [1, 3, 3, 2, -22.501972722776095],
        [1, 3, 3, 3, -16.957448329859460],
        [2, 1, 1, 1, -3.1494209150312722],
        [2, 1, 1, 2, 19.024376838885505],
        [2, 1, 1, 3, 8.0558318916305289],
        [2, 1, 2, 1, 19.024376838885505],
        [2, 1, 2, 2, -89.653784669207511],
        [2, 1, 2, 3, -36.745780464383401],
        [2, 1, 3, 1, 8.0558318916305289],
        [2, 1, 3, 2, -36.745780464383401],
        [2, 1, 3, 3, -19.192671848160998],
        [2, 2, 1, 1, 10.293213981001511],
        [2, 2, 1, 2, -89.653784669207511],
        [2, 2, 1, 3, -34.051435541355758],
        [2, 2, 2, 1, -89.653784669207511],
        [2, 2, 2, 2, 557.09229294461079],
        [2, 2, 2, 3, 188.76978511010742],
        [2, 2, 3, 1, -34.051435541355758],
        [2, 2, 3, 2, 188.76978511010742],
        [2, 2, 3, 3, 91.357116815294887],
        [2, 3, 1, 1, 5.5785936405303111],
        [2, 3, 1, 2, -36.745780464383401],
        [2, 3, 1, 3, -22.501972722776092],
        [2, 3, 2, 1, -36.745780464383401],
        [2, 3, 2, 2, 188.76978511010742],
        [2, 3, 2, 3, 119.19089730643179],
        [2, 3, 3, 1, -22.501972722776092],
        [2, 3, 3, 2, 119.19089730643179],
        [2, 3, 3, 3, 68.407412144454938],
        [3, 1, 1, 1, -1.6438110747420629],
        [3, 1, 1, 2, 8.0558318916305289],
        [3, 1, 1, 3, 6.1599002820183753],
        [3, 1, 2, 1, 8.0558318916305289],
        [3, 1, 2, 2, -34.051435541355758],
        [3, 1, 2, 3, -22.501972722776095],
        [3, 1, 3, 1, 6.1599002820183753],
        [3, 1, 3, 2, -22.501972722776095],
        [3, 1, 3, 3, -16.957448329859460],
        [3, 2, 1, 1, 5.5785936405303111],
        [3, 2, 1, 2, -36.745780464383401],
        [3, 2, 1, 3, -22.501972722776092],
        [3, 2, 2, 1, -36.745780464383401],
        [3, 2, 2, 2, 188.76978511010742],
        [3, 2, 2, 3, 119.19089730643179],
        [3, 2, 3, 1, -22.501972722776092],
        [3, 2, 3, 2, 119.19089730643179],
        [3, 2, 3, 3, 68.407412144454938],
        [3, 3, 1, 1, 2.5501822048834013],
        [3, 3, 1, 2, -19.192671848160998],
        [3, 3, 1, 3, -16.957448329859460],
        [3, 3, 2, 1, -19.192671848160998],
        [3, 3, 2, 2, 91.357116815294887],
        [3, 3, 2, 3, 68.407412144454938],
        [3, 3, 3, 1, -16.957448329859460],
        [3, 3, 3, 2, 68.407412144454938],
        [3, 3, 3, 3, 73.087161609769680],
    ]
    tensor = np.zeros((3, 3, 3, 3))
    for i, j, k, ll, value in data:
        tensor[i - 1, j - 1, k - 1, ll - 1] = value
    return tensor


def test_sef(neohooke):
    assert neohooke.sef == (neohooke.invariant1 - 3) * sym.Symbol("C10") + 0.25 * sym.Symbol("KBULK") * (
        neohooke.invariant3 - 1 - sym.log(neohooke.invariant3)
    )


def test_lambdify_sef(neohooke, c_tensor):
    sef_func = neohooke.substitute_iterator(neohooke.sef, c_tensor, {"C10": 1, "KBULK": 1})
    sef_values = np.array(list(sef_func))
    assert sef_values.shape == (4,)
    assert sef_values[0] == 0
    # all remaining values of SEF should be positive
    assert sef_values[1:].all() > 0


def test_lambdify_pk2(neohooke, c_tensor):
    # c10=1
    params = {"C10": 1, "KBULK": 0}
    pk2_func = neohooke.evaluate_iterator(neohooke.pk2(), c_tensor, **params)
    pk2_values = np.array(list(pk2_func))
    assert pk2_values.shape == (4, 3, 3)
    # no deformation
    assert np.allclose(pk2_values[0], 0)
    # uniaxial stretch 3 at x-axis
    assert np.allclose(
        pk2_values[1],
        [
            [1.2839506172839503, 0, 0],
            [0, -17.333333333333325, 0],
            [0, 0, -17.333333333333325],
        ],
    )
    # random deformation
    assert np.allclose(
        pk2_values[2],
        [
            [0.47698872071292914, 3.7974644907036370, 3.8146126481050007],
            [3.7974644907036370, -21.098062333064327, -10.149138565098266],
            [3.8146126481050007, -10.149138565098266, -26.762466478176837],
        ],
    )
    # random deformation2
    assert np.allclose(
        pk2_values[3],
        [
            [5.5268336167262878e-002, 6.1233382806947079, 3.1960197886296906],
            [6.1233382806947079, -36.662877397196567, -12.892944575515303],
            [3.1960197886296906, -12.892944575515303, -12.398475045842547],
        ],
    )


def test_lambdify_cmat_iso(neohooke, c_tensor, cmat_iso0, cmat_iso_uni, cmat_iso_arbitrary, cmat_iso_arbitrary2):
    params = {"C10": 1, "KBULK": 0}
    cmat_func = neohooke.evaluate_iterator(neohooke.cmat(), c_tensor, **params)
    cmat_values = np.array(list(cmat_func))
    assert cmat_values.shape == (4, 3, 3, 3, 3)
    assert np.allclose(cmat_values[0], cmat_iso0)
    assert np.allclose(cmat_values[1], cmat_iso_uni)
    assert np.allclose(cmat_values[2], cmat_iso_arbitrary)
    assert np.allclose(cmat_values[3], cmat_iso_arbitrary2)
