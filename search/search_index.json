{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"hyper-surrogate","text":"<p>Hyperelastic Surrogates</p>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradient","title":"<code>DeformationGradient</code>","text":"<p>A class representing deformation gradient operations.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>class DeformationGradient:\n    \"\"\"A class representing deformation gradient operations.\"\"\"\n\n    def __init__(self) -&gt; None:\n        pass\n\n    @staticmethod\n    def uniaxial(stretch: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the deformation gradient tensor for uniaxial deformation.\n\n        Args:\n            stretch: A 1D array representing the stretch factor.\n        Returns:\n            The deformation gradient tensor as a 3D array.\n        \"\"\"\n        stretch = np.atleast_1d(stretch)\n        # Calculate the transverse stretch factor for the entire array\n        stretch_t = stretch**-0.5\n        # Initialize the resulting 3D array with zeros\n        result = np.zeros((stretch.size, 3, 3))\n        # Fill in the diagonal values for each 2D sub-array\n        result[:, 0, 0] = stretch  # Set the first diagonal elements to stretch\n        result[:, 1, 1] = stretch_t  # Set the second diagonal elements to stretch_t\n        result[:, 2, 2] = stretch_t  # Set the third diagonal elements to stretch_t\n\n        return result\n\n    @staticmethod\n    def shear(shear: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the deformation gradient tensor for shear deformation.\n\n        Args:\n            shear: A 1D array representing the shear factor.\n\n        Returns:\n            The deformation gradient tensor as a 3D array.\n        \"\"\"\n        shear = np.atleast_1d(shear)\n        # Initialize the resulting 3D array with the identity matrix replicated for each shear value\n        result = np.repeat(np.eye(3)[np.newaxis, :, :], shear.size, axis=0)\n\n        # Set the shear values in the appropriate position for each 2D sub-array\n        result[:, 0, 1] = shear\n\n        return result\n\n    @staticmethod\n    def biaxial(stretch1: np.ndarray, stretch2: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the deformation gradient tensor for biaxial deformation.\n        latex equation:\n\n        Args:\n            stretch1: A 1D array representing the first stretch factor.\n            stretch2: A 1D array representing the second stretch factor.\n\n        Returns:\n            The deformation gradient tensor as a 3D array.\n        \"\"\"\n        # Calculate the third stretch factor for the entire arrays\n        stretch1 = np.atleast_1d(stretch1)\n        stretch2 = np.atleast_1d(stretch2)\n        stretch3 = (stretch1 * stretch2) ** -1.0\n\n        # Initialize the resulting 3D array with zeros\n        result = np.zeros((stretch1.size, 3, 3))\n\n        # Fill in the diagonal values for each 2D sub-array\n        result[:, 0, 0] = stretch1  # Set the first diagonal elements to stretch1\n        result[:, 1, 1] = stretch2  # Set the second diagonal elements to stretch2\n        result[:, 2, 2] = stretch3  # Set the third diagonal elements to stretch3\n\n        return result\n\n    @staticmethod\n    def _axis_rotation(axis: int, angle: float) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the rotation matrix for a given axis and angle.\n\n        Args:\n            axis: An integer representing the axis of rotation (0 for x-axis, 1 for y-axis, 2 for z-axis).\n            angle: A float representing the angle of rotation in radians.\n\n        Returns:\n            The rotation matrix as a 2D array.\n        \"\"\"\n        c, s = np.cos(angle), np.sin(angle)\n        dict_axis = {\n            0: np.array(\n                [\n                    [1, 0, 0],\n                    [0, c, -s],\n                    [0, s, c],\n                ]\n            ),\n            1: np.array(\n                [\n                    [c, 0, s],\n                    [0, 1, 0],\n                    [-s, 0, c],\n                ]\n            ),\n            2: np.array(\n                [\n                    [c, -s, 0],\n                    [s, c, 0],\n                    [0, 0, 1],\n                ]\n            ),\n        }\n        return dict_axis[axis] if axis in dict_axis else np.eye(3)\n\n    def rotation(self, axis: np.ndarray, angle: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the rotation matrix for multiple axes and angles.\n\n        Args:\n            axis: A 1D array representing the axes of rotation (0 for x-axis, 1 for y-axis, 2 for z-axis).\n            angle: A 1D array representing the angles of rotation in radians.\n\n        Returns:\n            The rotation matrix as a 3D array.\n        \"\"\"\n        axis, angle = np.atleast_1d(axis), np.atleast_1d(angle)\n        rotation = []\n        for ax, ang in zip(axis, angle):\n            rotation.append(self._axis_rotation(ax, ang))\n        return np.array(rotation)\n\n    def rescale(self, F: np.ndarray) -&gt; Any:\n        \"\"\"\n        Rescale the deformation gradient tensor.\n\n        Args:\n            F: The deformation gradient tensor as a 3D array.\n\n        Returns:\n            The rescaled deformation gradient tensor.\n        \"\"\"\n        return F / self.invariant3(F) ** (1.0 / 3.0)\n\n    @staticmethod\n    def invariant1(F: np.ndarray) -&gt; Any:\n        \"\"\"\n        Calculate the first invariant of the deformation gradient tensor.\n\n        Args:\n            F: The deformation gradient tensor as a 3D array.\n\n        Returns:\n            The first invariant.\n        \"\"\"\n        return np.trace(F)\n\n    @staticmethod\n    def invariant2(F: np.ndarray) -&gt; Any:\n        \"\"\"\n        Calculate the second invariant of the deformation gradient tensor.\n\n        Args:\n            F: The deformation gradient tensor as a 3D array.\n\n        Returns:\n            The second invariant.\n        \"\"\"\n        return 0.5 * (np.trace(F) ** 2 - np.trace(np.matmul(F, F)))\n\n    @staticmethod\n    def invariant3(F: np.ndarray) -&gt; Any:\n        \"\"\"\n        Calculate the third invariant of the deformation gradient tensor.\n\n        Args:\n            F: The deformation gradient tensor as a 3D array.\n\n        Returns:\n            The third invariant.\n        \"\"\"\n        return np.linalg.det(F)\n\n    @staticmethod\n    def to_radians(degree: float) -&gt; float:\n        \"\"\"\n        Convert degrees to radians.\n\n        Args:\n            degree: The angle in degrees.\n\n        Returns:\n            The angle in radians.\n        \"\"\"\n        return degree * np.pi / 180\n\n    @staticmethod\n    def rotate(F: np.ndarray, R: np.ndarray) -&gt; Any:\n        \"\"\"\n        Rotate the deformation gradient tensor.\n\n        Args:\n            F: The deformation gradient tensor as a 3D array.\n            R: The rotation matrix as a 3D array.\n\n        Returns:\n            The rotated deformation gradient tensor.\n        \"\"\"\n        F = np.atleast_3d(F)\n        R = np.atleast_3d(R)\n        return np.einsum(\"nij,njk,nlk-&gt;nil\", R, F, R)\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradient.biaxial","title":"<code>biaxial(stretch1, stretch2)</code>  <code>staticmethod</code>","text":"<p>Calculate the deformation gradient tensor for biaxial deformation. latex equation:</p> <p>Parameters:</p> Name Type Description Default <code>stretch1</code> <code>ndarray</code> <p>A 1D array representing the first stretch factor.</p> required <code>stretch2</code> <code>ndarray</code> <p>A 1D array representing the second stretch factor.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The deformation gradient tensor as a 3D array.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>@staticmethod\ndef biaxial(stretch1: np.ndarray, stretch2: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the deformation gradient tensor for biaxial deformation.\n    latex equation:\n\n    Args:\n        stretch1: A 1D array representing the first stretch factor.\n        stretch2: A 1D array representing the second stretch factor.\n\n    Returns:\n        The deformation gradient tensor as a 3D array.\n    \"\"\"\n    # Calculate the third stretch factor for the entire arrays\n    stretch1 = np.atleast_1d(stretch1)\n    stretch2 = np.atleast_1d(stretch2)\n    stretch3 = (stretch1 * stretch2) ** -1.0\n\n    # Initialize the resulting 3D array with zeros\n    result = np.zeros((stretch1.size, 3, 3))\n\n    # Fill in the diagonal values for each 2D sub-array\n    result[:, 0, 0] = stretch1  # Set the first diagonal elements to stretch1\n    result[:, 1, 1] = stretch2  # Set the second diagonal elements to stretch2\n    result[:, 2, 2] = stretch3  # Set the third diagonal elements to stretch3\n\n    return result\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradient.invariant1","title":"<code>invariant1(F)</code>  <code>staticmethod</code>","text":"<p>Calculate the first invariant of the deformation gradient tensor.</p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>ndarray</code> <p>The deformation gradient tensor as a 3D array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The first invariant.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>@staticmethod\ndef invariant1(F: np.ndarray) -&gt; Any:\n    \"\"\"\n    Calculate the first invariant of the deformation gradient tensor.\n\n    Args:\n        F: The deformation gradient tensor as a 3D array.\n\n    Returns:\n        The first invariant.\n    \"\"\"\n    return np.trace(F)\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradient.invariant2","title":"<code>invariant2(F)</code>  <code>staticmethod</code>","text":"<p>Calculate the second invariant of the deformation gradient tensor.</p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>ndarray</code> <p>The deformation gradient tensor as a 3D array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The second invariant.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>@staticmethod\ndef invariant2(F: np.ndarray) -&gt; Any:\n    \"\"\"\n    Calculate the second invariant of the deformation gradient tensor.\n\n    Args:\n        F: The deformation gradient tensor as a 3D array.\n\n    Returns:\n        The second invariant.\n    \"\"\"\n    return 0.5 * (np.trace(F) ** 2 - np.trace(np.matmul(F, F)))\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradient.invariant3","title":"<code>invariant3(F)</code>  <code>staticmethod</code>","text":"<p>Calculate the third invariant of the deformation gradient tensor.</p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>ndarray</code> <p>The deformation gradient tensor as a 3D array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The third invariant.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>@staticmethod\ndef invariant3(F: np.ndarray) -&gt; Any:\n    \"\"\"\n    Calculate the third invariant of the deformation gradient tensor.\n\n    Args:\n        F: The deformation gradient tensor as a 3D array.\n\n    Returns:\n        The third invariant.\n    \"\"\"\n    return np.linalg.det(F)\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradient.rescale","title":"<code>rescale(F)</code>","text":"<p>Rescale the deformation gradient tensor.</p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>ndarray</code> <p>The deformation gradient tensor as a 3D array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The rescaled deformation gradient tensor.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>def rescale(self, F: np.ndarray) -&gt; Any:\n    \"\"\"\n    Rescale the deformation gradient tensor.\n\n    Args:\n        F: The deformation gradient tensor as a 3D array.\n\n    Returns:\n        The rescaled deformation gradient tensor.\n    \"\"\"\n    return F / self.invariant3(F) ** (1.0 / 3.0)\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradient.rotate","title":"<code>rotate(F, R)</code>  <code>staticmethod</code>","text":"<p>Rotate the deformation gradient tensor.</p> <p>Parameters:</p> Name Type Description Default <code>F</code> <code>ndarray</code> <p>The deformation gradient tensor as a 3D array.</p> required <code>R</code> <code>ndarray</code> <p>The rotation matrix as a 3D array.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The rotated deformation gradient tensor.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>@staticmethod\ndef rotate(F: np.ndarray, R: np.ndarray) -&gt; Any:\n    \"\"\"\n    Rotate the deformation gradient tensor.\n\n    Args:\n        F: The deformation gradient tensor as a 3D array.\n        R: The rotation matrix as a 3D array.\n\n    Returns:\n        The rotated deformation gradient tensor.\n    \"\"\"\n    F = np.atleast_3d(F)\n    R = np.atleast_3d(R)\n    return np.einsum(\"nij,njk,nlk-&gt;nil\", R, F, R)\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradient.rotation","title":"<code>rotation(axis, angle)</code>","text":"<p>Calculate the rotation matrix for multiple axes and angles.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>A 1D array representing the axes of rotation (0 for x-axis, 1 for y-axis, 2 for z-axis).</p> required <code>angle</code> <code>ndarray</code> <p>A 1D array representing the angles of rotation in radians.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The rotation matrix as a 3D array.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>def rotation(self, axis: np.ndarray, angle: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the rotation matrix for multiple axes and angles.\n\n    Args:\n        axis: A 1D array representing the axes of rotation (0 for x-axis, 1 for y-axis, 2 for z-axis).\n        angle: A 1D array representing the angles of rotation in radians.\n\n    Returns:\n        The rotation matrix as a 3D array.\n    \"\"\"\n    axis, angle = np.atleast_1d(axis), np.atleast_1d(angle)\n    rotation = []\n    for ax, ang in zip(axis, angle):\n        rotation.append(self._axis_rotation(ax, ang))\n    return np.array(rotation)\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradient.shear","title":"<code>shear(shear)</code>  <code>staticmethod</code>","text":"<p>Calculate the deformation gradient tensor for shear deformation.</p> <p>Parameters:</p> Name Type Description Default <code>shear</code> <code>ndarray</code> <p>A 1D array representing the shear factor.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The deformation gradient tensor as a 3D array.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>@staticmethod\ndef shear(shear: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the deformation gradient tensor for shear deformation.\n\n    Args:\n        shear: A 1D array representing the shear factor.\n\n    Returns:\n        The deformation gradient tensor as a 3D array.\n    \"\"\"\n    shear = np.atleast_1d(shear)\n    # Initialize the resulting 3D array with the identity matrix replicated for each shear value\n    result = np.repeat(np.eye(3)[np.newaxis, :, :], shear.size, axis=0)\n\n    # Set the shear values in the appropriate position for each 2D sub-array\n    result[:, 0, 1] = shear\n\n    return result\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradient.to_radians","title":"<code>to_radians(degree)</code>  <code>staticmethod</code>","text":"<p>Convert degrees to radians.</p> <p>Parameters:</p> Name Type Description Default <code>degree</code> <code>float</code> <p>The angle in degrees.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The angle in radians.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>@staticmethod\ndef to_radians(degree: float) -&gt; float:\n    \"\"\"\n    Convert degrees to radians.\n\n    Args:\n        degree: The angle in degrees.\n\n    Returns:\n        The angle in radians.\n    \"\"\"\n    return degree * np.pi / 180\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradient.uniaxial","title":"<code>uniaxial(stretch)</code>  <code>staticmethod</code>","text":"<p>Calculate the deformation gradient tensor for uniaxial deformation.</p> <p>Parameters:</p> Name Type Description Default <code>stretch</code> <code>ndarray</code> <p>A 1D array representing the stretch factor.</p> required <p>Returns:     The deformation gradient tensor as a 3D array.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>@staticmethod\ndef uniaxial(stretch: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the deformation gradient tensor for uniaxial deformation.\n\n    Args:\n        stretch: A 1D array representing the stretch factor.\n    Returns:\n        The deformation gradient tensor as a 3D array.\n    \"\"\"\n    stretch = np.atleast_1d(stretch)\n    # Calculate the transverse stretch factor for the entire array\n    stretch_t = stretch**-0.5\n    # Initialize the resulting 3D array with zeros\n    result = np.zeros((stretch.size, 3, 3))\n    # Fill in the diagonal values for each 2D sub-array\n    result[:, 0, 0] = stretch  # Set the first diagonal elements to stretch\n    result[:, 1, 1] = stretch_t  # Set the second diagonal elements to stretch_t\n    result[:, 2, 2] = stretch_t  # Set the third diagonal elements to stretch_t\n\n    return result\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradientGenerator","title":"<code>DeformationGradientGenerator</code>","text":"<p>             Bases: <code>DeformationGradient</code></p> <p>Generates deformation gradients for hyper-surrogate modeling.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int | None</code> <p>Seed value for the random number generator. Default is None.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>Size of the generator. Default is None.</p> <code>None</code> <code>generator</code> <code>Generator | None</code> <p>Random number generator. Default is None.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>seed</code> <code>int | None</code> <p>Seed value for the random number generator.</p> <code>size</code> <code>int | None</code> <p>Size of the generator.</p> <code>generator</code> <code>Generator</code> <p>Random number generator.</p> <p>Methods:</p> Name Description <code>axis</code> <p>int = 3) -&gt; Any: Generates a random axis.</p> <code>angle</code> <p>float = 5) -&gt; Any: Generates a random angle.</p> <code>generate_rotation</code> <p>int = 3, min_interval: float = 5) -&gt; np.ndarray: Generates a random rotation matrix.</p> <code>generate</code> <p>float = 0.4, stretch_max: float = 3.0, shear_min: float = -1, shear_max: float = 1) -&gt; Any: Generates a deformation gradient.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>class DeformationGradientGenerator(DeformationGradient):\n    \"\"\"\n    Generates deformation gradients for hyper-surrogate modeling.\n\n    Args:\n        seed (int | None): Seed value for the random number generator. Default is None.\n        size (int | None): Size of the generator. Default is None.\n        generator (Generator | None): Random number generator. Default is None.\n\n    Attributes:\n        seed (int | None): Seed value for the random number generator.\n        size (int | None): Size of the generator.\n        generator (Generator): Random number generator.\n\n    Methods:\n        axis(n_axis: int = 3) -&gt; Any:\n            Generates a random axis.\n\n        angle(min_interval: float = 5) -&gt; Any:\n            Generates a random angle.\n\n        generate_rotation(n_axis: int = 3, min_interval: float = 5) -&gt; np.ndarray:\n            Generates a random rotation matrix.\n\n        generate(stretch_min: float = 0.4, stretch_max: float = 3.0, shear_min: float = -1, shear_max: float = 1) -&gt; Any:\n            Generates a deformation gradient.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        seed: int | None = None,\n        size: int | None = None,\n        generator: Generator | None = None,\n    ) -&gt; None:\n        self.seed = seed\n        self.size = size\n        self.generator = generator if generator else Generator(seed=seed, size=size)\n\n    def axis(self, n_axis: int = 3) -&gt; Any:\n        \"\"\"\n        Generates a random axis.\n\n        Args:\n            n_axis (int): Number of axes to choose from. Default is 3.\n\n        Returns:\n            Any: Randomly generated axis.\n\n        \"\"\"\n        return self.generator.integer_in_interval(low=0, high=n_axis)\n\n    def angle(self, min_interval: float = 5) -&gt; Any:\n        \"\"\"\n        Generates a random angle.\n\n        Args:\n            min_interval (float): Minimum interval for the angle. Default is 5.\n\n        Returns:\n            Any: Randomly generated angle.\n\n        \"\"\"\n        min_interval = self.to_radians(min_interval)\n        return self.generator.float_in_interval(a=0, b=np.pi, interval=min_interval)\n\n    def generate_rotation(self, n_axis: int = 3, min_interval: float = 5) -&gt; np.ndarray:\n        \"\"\"\n        Generates a random rotation matrix.\n\n        Args:\n            n_axis (int): Number of axes to choose from. Default is 3.\n            min_interval (float): Minimum interval for the angle. Default is 5.\n\n        Returns:\n            np.ndarray: Randomly generated rotation matrix.\n\n        \"\"\"\n        axis = self.axis(n_axis=n_axis)\n        angle = self.angle(min_interval=min_interval)\n        return self.rotation(axis, angle)\n\n    def generate(\n        self,\n        stretch_min: float = 0.4,\n        stretch_max: float = 3.0,\n        shear_min: float = -1,\n        shear_max: float = 1,\n    ) -&gt; Any:\n        \"\"\"\n        Generates a random deformation gradient.\n\n        Args:\n            stretch_min (float): Minimum value for stretch. Default is 0.4.\n            stretch_max (float): Maximum value for stretch. Default is 3.0.\n            shear_min (float): Minimum value for shear. Default is -1.\n            shear_max (float): Maximum value for shear. Default is 1.\n\n        Returns:\n            Any: Generated random deformation gradient.\n\n        \"\"\"\n        u, s, b1, b2 = (\n            self.generator.uniform(stretch_min, stretch_max),\n            self.generator.uniform(shear_min, shear_max),\n            self.generator.uniform(stretch_min, stretch_max),\n            self.generator.uniform(stretch_min, stretch_max),\n        )\n        fu, fs, fb = (\n            self.uniaxial(u),\n            self.shear(s),\n            self.biaxial(b1, b2),\n        )\n        r1, r2, r3 = (\n            self.generate_rotation(),\n            self.generate_rotation(),\n            self.generate_rotation(),\n        )\n\n        # rotate deformation gradients\n        fu = self.rotate(fu, r1)\n        fs = self.rotate(fs, r2)\n        fb = self.rotate(fb, r3)\n\n        # Compute deformation gradient\n        return np.matmul(np.matmul(fb, fu), fs)\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradientGenerator.angle","title":"<code>angle(min_interval=5)</code>","text":"<p>Generates a random angle.</p> <p>Parameters:</p> Name Type Description Default <code>min_interval</code> <code>float</code> <p>Minimum interval for the angle. Default is 5.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Randomly generated angle.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>def angle(self, min_interval: float = 5) -&gt; Any:\n    \"\"\"\n    Generates a random angle.\n\n    Args:\n        min_interval (float): Minimum interval for the angle. Default is 5.\n\n    Returns:\n        Any: Randomly generated angle.\n\n    \"\"\"\n    min_interval = self.to_radians(min_interval)\n    return self.generator.float_in_interval(a=0, b=np.pi, interval=min_interval)\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradientGenerator.axis","title":"<code>axis(n_axis=3)</code>","text":"<p>Generates a random axis.</p> <p>Parameters:</p> Name Type Description Default <code>n_axis</code> <code>int</code> <p>Number of axes to choose from. Default is 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Randomly generated axis.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>def axis(self, n_axis: int = 3) -&gt; Any:\n    \"\"\"\n    Generates a random axis.\n\n    Args:\n        n_axis (int): Number of axes to choose from. Default is 3.\n\n    Returns:\n        Any: Randomly generated axis.\n\n    \"\"\"\n    return self.generator.integer_in_interval(low=0, high=n_axis)\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradientGenerator.generate","title":"<code>generate(stretch_min=0.4, stretch_max=3.0, shear_min=-1, shear_max=1)</code>","text":"<p>Generates a random deformation gradient.</p> <p>Parameters:</p> Name Type Description Default <code>stretch_min</code> <code>float</code> <p>Minimum value for stretch. Default is 0.4.</p> <code>0.4</code> <code>stretch_max</code> <code>float</code> <p>Maximum value for stretch. Default is 3.0.</p> <code>3.0</code> <code>shear_min</code> <code>float</code> <p>Minimum value for shear. Default is -1.</p> <code>-1</code> <code>shear_max</code> <code>float</code> <p>Maximum value for shear. Default is 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Generated random deformation gradient.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>def generate(\n    self,\n    stretch_min: float = 0.4,\n    stretch_max: float = 3.0,\n    shear_min: float = -1,\n    shear_max: float = 1,\n) -&gt; Any:\n    \"\"\"\n    Generates a random deformation gradient.\n\n    Args:\n        stretch_min (float): Minimum value for stretch. Default is 0.4.\n        stretch_max (float): Maximum value for stretch. Default is 3.0.\n        shear_min (float): Minimum value for shear. Default is -1.\n        shear_max (float): Maximum value for shear. Default is 1.\n\n    Returns:\n        Any: Generated random deformation gradient.\n\n    \"\"\"\n    u, s, b1, b2 = (\n        self.generator.uniform(stretch_min, stretch_max),\n        self.generator.uniform(shear_min, shear_max),\n        self.generator.uniform(stretch_min, stretch_max),\n        self.generator.uniform(stretch_min, stretch_max),\n    )\n    fu, fs, fb = (\n        self.uniaxial(u),\n        self.shear(s),\n        self.biaxial(b1, b2),\n    )\n    r1, r2, r3 = (\n        self.generate_rotation(),\n        self.generate_rotation(),\n        self.generate_rotation(),\n    )\n\n    # rotate deformation gradients\n    fu = self.rotate(fu, r1)\n    fs = self.rotate(fs, r2)\n    fb = self.rotate(fb, r3)\n\n    # Compute deformation gradient\n    return np.matmul(np.matmul(fb, fu), fs)\n</code></pre>"},{"location":"modules/#hyper_surrogate.deformation_gradient.DeformationGradientGenerator.generate_rotation","title":"<code>generate_rotation(n_axis=3, min_interval=5)</code>","text":"<p>Generates a random rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_axis</code> <code>int</code> <p>Number of axes to choose from. Default is 3.</p> <code>3</code> <code>min_interval</code> <code>float</code> <p>Minimum interval for the angle. Default is 5.</p> <code>5</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Randomly generated rotation matrix.</p> Source code in <code>hyper_surrogate/deformation_gradient.py</code> <pre><code>def generate_rotation(self, n_axis: int = 3, min_interval: float = 5) -&gt; np.ndarray:\n    \"\"\"\n    Generates a random rotation matrix.\n\n    Args:\n        n_axis (int): Number of axes to choose from. Default is 3.\n        min_interval (float): Minimum interval for the angle. Default is 5.\n\n    Returns:\n        np.ndarray: Randomly generated rotation matrix.\n\n    \"\"\"\n    axis = self.axis(n_axis=n_axis)\n    angle = self.angle(min_interval=min_interval)\n    return self.rotation(axis, angle)\n</code></pre>"},{"location":"modules/#hyper_surrogate.generator.Generator","title":"<code>Generator</code>","text":"<p>A class that provides various random number generation methods.</p> Source code in <code>hyper_surrogate/generator.py</code> <pre><code>class Generator:\n    \"\"\"A class that provides various random number generation methods.\"\"\"\n\n    def __init__(self, seed: int | None = None, size: int | None = None) -&gt; None:\n        \"\"\"\n        Initialize the Generator object.\n\n        Args:\n            seed (int | None): The seed value for random number generation. If None, a random seed will be used.\n            size (int | None): The size of the generated random numbers. If None, a single random number will be generated.\n\n        Returns:\n            None\n        \"\"\"\n        self.seed = seed\n        self.size = size\n        np.random.seed(self.seed)\n\n    def uniform(self, low: float, high: float) -&gt; np.ndarray:\n        \"\"\"\n        Generate random numbers from a uniform distribution.\n\n        Args:\n            low (float): The lower bound of the distribution.\n            high (float): The upper bound of the distribution.\n\n        Returns:\n            np.ndarray: An array of random numbers from the uniform distribution.\n        \"\"\"\n        return np.random.uniform(low, high, size=self.size)\n\n    def integer_in_interval(self, low: int = 0, high: int = 3) -&gt; np.ndarray[Any, Any]:\n        \"\"\"\n        Generate random integers in the specified interval.\n\n        Args:\n            low (int): The lower bound of the interval (inclusive).\n            high (int): The upper bound of the interval (exclusive).\n\n        Returns:\n            np.ndarray: An array of random integers in the specified interval.\n        \"\"\"\n        return np.random.randint(low, high, size=self.size)\n\n    def float_in_interval(self, a: float = 0, b: float = 180, interval: float = 5) -&gt; np.ndarray[Any, Any]:\n        \"\"\"\n        Generate random numbers in the specified interval with a given interval.\n\n        Args:\n            a (float): The lower bound of the interval.\n            b (float): The upper bound of the interval.\n            interval (float): The interval between the generated numbers.\n\n        Returns:\n            np.ndarray: An array of random numbers in the specified interval.\n        \"\"\"\n        if interval &lt;= 0 or interval &gt;= 180 or interval == 0:\n            return np.array([0])\n        return np.random.choice(np.arange(a, b + interval, interval), size=self.size)\n\n    def normal(self, loc: float, scale: float) -&gt; np.ndarray:\n        \"\"\"\n        Generate random numbers from a normal distribution.\n\n        Args:\n            loc (float): The mean of the distribution.\n            scale (float): The standard deviation of the distribution.\n\n        Returns:\n            np.ndarray: An array of random numbers from the normal distribution.\n        \"\"\"\n        return np.random.normal(loc, scale, size=self.size)\n\n    def lognormal(self, mean: float, sigma: float) -&gt; np.ndarray:\n        \"\"\"\n        Generate random numbers from a log-normal distribution.\n\n        Args:\n            mean (float): The mean of the underlying normal distribution.\n            sigma (float): The standard deviation of the underlying normal distribution.\n\n        Returns:\n            np.ndarray: An array of random numbers from the log-normal distribution.\n        \"\"\"\n        return np.random.lognormal(mean, sigma, size=self.size)\n\n    def beta(self, a: float, b: float) -&gt; np.ndarray:\n        \"\"\"\n        Generate random numbers from a beta distribution.\n\n        Args:\n            a (float): The shape parameter (alpha) of the distribution.\n            b (float): The shape parameter (beta) of the distribution.\n\n        Returns:\n            np.ndarray: An array of random numbers from the beta distribution.\n        \"\"\"\n        return np.random.beta(a, b, size=self.size)\n\n    def gamma(self, shape: float, scale: float) -&gt; np.ndarray:\n        \"\"\"\n        Generate random numbers from a gamma distribution.\n\n        Args:\n            shape (float): The shape parameter (k) of the distribution.\n            scale (float): The scale parameter (theta) of the distribution.\n\n        Returns:\n            np.ndarray: An array of random numbers from the gamma distribution.\n        \"\"\"\n        return np.random.gamma(shape, scale, size=self.size)\n\n    def weibull(self, a: float) -&gt; np.ndarray:\n        \"\"\"\n        Generate random numbers from a Weibull distribution.\n\n        Args:\n            a (float): The shape parameter (k) of the distribution.\n\n        Returns:\n            np.ndarray: An array of random numbers from the Weibull distribution.\n        \"\"\"\n        return np.random.weibull(a, size=self.size)\n</code></pre>"},{"location":"modules/#hyper_surrogate.generator.Generator.__init__","title":"<code>__init__(seed=None, size=None)</code>","text":"<p>Initialize the Generator object.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int | None</code> <p>The seed value for random number generation. If None, a random seed will be used.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The size of the generated random numbers. If None, a single random number will be generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>hyper_surrogate/generator.py</code> <pre><code>def __init__(self, seed: int | None = None, size: int | None = None) -&gt; None:\n    \"\"\"\n    Initialize the Generator object.\n\n    Args:\n        seed (int | None): The seed value for random number generation. If None, a random seed will be used.\n        size (int | None): The size of the generated random numbers. If None, a single random number will be generated.\n\n    Returns:\n        None\n    \"\"\"\n    self.seed = seed\n    self.size = size\n    np.random.seed(self.seed)\n</code></pre>"},{"location":"modules/#hyper_surrogate.generator.Generator.beta","title":"<code>beta(a, b)</code>","text":"<p>Generate random numbers from a beta distribution.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The shape parameter (alpha) of the distribution.</p> required <code>b</code> <code>float</code> <p>The shape parameter (beta) of the distribution.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array of random numbers from the beta distribution.</p> Source code in <code>hyper_surrogate/generator.py</code> <pre><code>def beta(self, a: float, b: float) -&gt; np.ndarray:\n    \"\"\"\n    Generate random numbers from a beta distribution.\n\n    Args:\n        a (float): The shape parameter (alpha) of the distribution.\n        b (float): The shape parameter (beta) of the distribution.\n\n    Returns:\n        np.ndarray: An array of random numbers from the beta distribution.\n    \"\"\"\n    return np.random.beta(a, b, size=self.size)\n</code></pre>"},{"location":"modules/#hyper_surrogate.generator.Generator.float_in_interval","title":"<code>float_in_interval(a=0, b=180, interval=5)</code>","text":"<p>Generate random numbers in the specified interval with a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The lower bound of the interval.</p> <code>0</code> <code>b</code> <code>float</code> <p>The upper bound of the interval.</p> <code>180</code> <code>interval</code> <code>float</code> <p>The interval between the generated numbers.</p> <code>5</code> <p>Returns:</p> Type Description <code>ndarray[Any, Any]</code> <p>np.ndarray: An array of random numbers in the specified interval.</p> Source code in <code>hyper_surrogate/generator.py</code> <pre><code>def float_in_interval(self, a: float = 0, b: float = 180, interval: float = 5) -&gt; np.ndarray[Any, Any]:\n    \"\"\"\n    Generate random numbers in the specified interval with a given interval.\n\n    Args:\n        a (float): The lower bound of the interval.\n        b (float): The upper bound of the interval.\n        interval (float): The interval between the generated numbers.\n\n    Returns:\n        np.ndarray: An array of random numbers in the specified interval.\n    \"\"\"\n    if interval &lt;= 0 or interval &gt;= 180 or interval == 0:\n        return np.array([0])\n    return np.random.choice(np.arange(a, b + interval, interval), size=self.size)\n</code></pre>"},{"location":"modules/#hyper_surrogate.generator.Generator.gamma","title":"<code>gamma(shape, scale)</code>","text":"<p>Generate random numbers from a gamma distribution.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>float</code> <p>The shape parameter (k) of the distribution.</p> required <code>scale</code> <code>float</code> <p>The scale parameter (theta) of the distribution.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array of random numbers from the gamma distribution.</p> Source code in <code>hyper_surrogate/generator.py</code> <pre><code>def gamma(self, shape: float, scale: float) -&gt; np.ndarray:\n    \"\"\"\n    Generate random numbers from a gamma distribution.\n\n    Args:\n        shape (float): The shape parameter (k) of the distribution.\n        scale (float): The scale parameter (theta) of the distribution.\n\n    Returns:\n        np.ndarray: An array of random numbers from the gamma distribution.\n    \"\"\"\n    return np.random.gamma(shape, scale, size=self.size)\n</code></pre>"},{"location":"modules/#hyper_surrogate.generator.Generator.integer_in_interval","title":"<code>integer_in_interval(low=0, high=3)</code>","text":"<p>Generate random integers in the specified interval.</p> <p>Parameters:</p> Name Type Description Default <code>low</code> <code>int</code> <p>The lower bound of the interval (inclusive).</p> <code>0</code> <code>high</code> <code>int</code> <p>The upper bound of the interval (exclusive).</p> <code>3</code> <p>Returns:</p> Type Description <code>ndarray[Any, Any]</code> <p>np.ndarray: An array of random integers in the specified interval.</p> Source code in <code>hyper_surrogate/generator.py</code> <pre><code>def integer_in_interval(self, low: int = 0, high: int = 3) -&gt; np.ndarray[Any, Any]:\n    \"\"\"\n    Generate random integers in the specified interval.\n\n    Args:\n        low (int): The lower bound of the interval (inclusive).\n        high (int): The upper bound of the interval (exclusive).\n\n    Returns:\n        np.ndarray: An array of random integers in the specified interval.\n    \"\"\"\n    return np.random.randint(low, high, size=self.size)\n</code></pre>"},{"location":"modules/#hyper_surrogate.generator.Generator.lognormal","title":"<code>lognormal(mean, sigma)</code>","text":"<p>Generate random numbers from a log-normal distribution.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>float</code> <p>The mean of the underlying normal distribution.</p> required <code>sigma</code> <code>float</code> <p>The standard deviation of the underlying normal distribution.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array of random numbers from the log-normal distribution.</p> Source code in <code>hyper_surrogate/generator.py</code> <pre><code>def lognormal(self, mean: float, sigma: float) -&gt; np.ndarray:\n    \"\"\"\n    Generate random numbers from a log-normal distribution.\n\n    Args:\n        mean (float): The mean of the underlying normal distribution.\n        sigma (float): The standard deviation of the underlying normal distribution.\n\n    Returns:\n        np.ndarray: An array of random numbers from the log-normal distribution.\n    \"\"\"\n    return np.random.lognormal(mean, sigma, size=self.size)\n</code></pre>"},{"location":"modules/#hyper_surrogate.generator.Generator.normal","title":"<code>normal(loc, scale)</code>","text":"<p>Generate random numbers from a normal distribution.</p> <p>Parameters:</p> Name Type Description Default <code>loc</code> <code>float</code> <p>The mean of the distribution.</p> required <code>scale</code> <code>float</code> <p>The standard deviation of the distribution.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array of random numbers from the normal distribution.</p> Source code in <code>hyper_surrogate/generator.py</code> <pre><code>def normal(self, loc: float, scale: float) -&gt; np.ndarray:\n    \"\"\"\n    Generate random numbers from a normal distribution.\n\n    Args:\n        loc (float): The mean of the distribution.\n        scale (float): The standard deviation of the distribution.\n\n    Returns:\n        np.ndarray: An array of random numbers from the normal distribution.\n    \"\"\"\n    return np.random.normal(loc, scale, size=self.size)\n</code></pre>"},{"location":"modules/#hyper_surrogate.generator.Generator.uniform","title":"<code>uniform(low, high)</code>","text":"<p>Generate random numbers from a uniform distribution.</p> <p>Parameters:</p> Name Type Description Default <code>low</code> <code>float</code> <p>The lower bound of the distribution.</p> required <code>high</code> <code>float</code> <p>The upper bound of the distribution.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array of random numbers from the uniform distribution.</p> Source code in <code>hyper_surrogate/generator.py</code> <pre><code>def uniform(self, low: float, high: float) -&gt; np.ndarray:\n    \"\"\"\n    Generate random numbers from a uniform distribution.\n\n    Args:\n        low (float): The lower bound of the distribution.\n        high (float): The upper bound of the distribution.\n\n    Returns:\n        np.ndarray: An array of random numbers from the uniform distribution.\n    \"\"\"\n    return np.random.uniform(low, high, size=self.size)\n</code></pre>"},{"location":"modules/#hyper_surrogate.generator.Generator.weibull","title":"<code>weibull(a)</code>","text":"<p>Generate random numbers from a Weibull distribution.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The shape parameter (k) of the distribution.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array of random numbers from the Weibull distribution.</p> Source code in <code>hyper_surrogate/generator.py</code> <pre><code>def weibull(self, a: float) -&gt; np.ndarray:\n    \"\"\"\n    Generate random numbers from a Weibull distribution.\n\n    Args:\n        a (float): The shape parameter (k) of the distribution.\n\n    Returns:\n        np.ndarray: An array of random numbers from the Weibull distribution.\n    \"\"\"\n    return np.random.weibull(a, size=self.size)\n</code></pre>"}]}